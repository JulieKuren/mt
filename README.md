# Automatic Generation of True-False Questions for Educational Purposes

The generation procedure is rule-based and consists of the following steps:

1. True statement generation.
2. Alternative statement generation.
3. True-False question creation and ranking.
4. Reading Comprehension exercise creation.

## Prerequisites

1. [Download](https://nlp.stanford.edu/software/stanford-corenlp-full-2018-10-05.zip), unpack, and run StanfordCoreNLP:

   ```sh
   unzip stanford-corenlp-full-2018-10-05.zip
   cd stanford-corenlp-full-2018-10-05.zip
   java -mx4g -cp "*" edu.stanford.nlp.pipeline.StanfordCoreNLPServer
   ```

2. Install MySQL (needed for the pattern package):

   ```sh
   brew install mysql
   ```

3. Install python dependencies:

   ```sh
   pip install -r requirements.txt
   ```

4. Install nltk resources:

   ```python
   python
   >>> import nltk
   >>> nltk.download("punkt")
   ```

## True Statement Generation

True statements are created by applying a set of rules to RST relations found in the text. In order to generate True statements, run the `project/generation.ipynb` Jupyter notebook. The notebook has two constants that define its behaviour:

```python
RACE_PART = "test/middle"
OUTPUT_DIR = "statements_7"
```

The first constant defines the part of the RACE dataset that will be used for True statement generation. The notebook will expect RST parsing results in `../parsed/race/{RACE_PART} `. Note that it takes RST parsing results (not raw texts) as its input. The RST parsing results should be stored in separate files (one for each text).

The second constant specifies the output location. True statements generated from an input file `../parsed/race/{RACE_PART}/foo.txt.tree` by applying rule `rule_01` will be saved in `{OUTPUT_DIR}/rule_01/{RACE_PART}/foo.txt.tree`. Output files have the json format. Here is an example of an output file:

```json
[
  {
    "statement_text": "He took a thermos out of his bag. That is why the other two men were very surprised.",
    "nucleus": "He took a thermos out of his bag.",
    "connective": " That is why ",
    "satellite_nucleus": "the other two men were very surprised.",
    "left_boundary": 1118,
    "right_boundary": 1507,
    "split_point": 1173,
    "nucleus_proximity": "near",
    "rule": "explanation_02",
    "reason": [
      4,
      "Common pattern; nucleus has nested relations."
    ]
  }
]
```

The output file above contains one statement generated by applying rule `explanation_02`. In addition to the statement itself and the name of the rule, the json structure has several auxiliary fields. Their meaning is explained in the following table.

| key               | meaning                                                      |
| ----------------- | ------------------------------------------------------------ |
| nucleus           | the part of the relation coming from the nucleus of the respective RST relation |
| connective        | the connective added during the creation of the statement    |
| satellite_nucleus | the part of the relation coming from the satellite's nucleus of the RST relation |
| left_boundary     | the left boundary of the RST relation in the text            |
| right_boundary    | the right boundary of the RST relation in the text           |
| split_point       | the boundary between the nucleus and the satellite of the RST relation |
| nucleus_proximity | indicates whether the nucleus and the satellite of the RST relation are adjacent |
| reason            | the satisfied criterion for applying the rule (an internal code and a text description of that criterion) |

